<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Florida Wetlands — Types & Toggles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
  <style>
    html, body, #map {height:100%; margin:0}
    .panel {
      position:absolute; top:10px; left:10px; z-index:2;
      background:#fff; border-radius:10px; padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.15);
      max-height:70%; overflow:auto; font-family:system-ui, sans-serif; font-size:14px;
    }
    .row {display:flex; align-items:center; gap:8px; margin:4px 0;}
    .swatch {width:14px; height:14px; border-radius:3px; border:1px solid #888;}
    .panel h3 {margin:0 0 8px 0; font-size:15px;}
    .btns {display:flex; gap:8px; margin-bottom:6px}
    button {cursor:pointer; padding:4px 8px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7}
  </style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <h3>Wetland Types</h3>
  <div class="btns">
    <button id="selectAll">Select all</button>
    <button id="clearAll">Clear all</button>
  </div>
  <div id="typeList">Loading…</div>
</div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script>
  // ---- CONFIG ----
  const PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/wetlands.pmtiles";
  const SOURCE_ID = "wetlands";
  const SOURCE_LAYER = "wetlands";   // tippecanoe -l name (default we used)
  const TYPE_FIELD = "type";

  // ---- Map init ----
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      "version": 8,
      "sources": {
        [SOURCE_ID]: { "type": "vector", "url": PMTILES_URL }
      },
      "layers": [
        {
          "id": "wetlands-fill",
          "type": "fill",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": {
            "fill-color": "#66bb6a",     // temporary; we’ll set data-driven color after discovery
            "fill-opacity": 0.35
          },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]] // start empty; we'll populate
        },
        {
          "id": "wetlands-outline",
          "type": "line",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": { "line-color": "#22663f", "line-width": 0.6 },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]]
        }
      ]
    },
    center: [-81.5, 28.5],
    zoom: 6
  });

  // ---- Helpers ----
  // Stable color from string via simple hash → HSL
  function colorForType(s){
    let h=0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i))>>>0;
    const hue = h % 360;
    return `hsl(${hue},60%,55%)`;
  }

  function buildColorExpression(types){
    // ["match", ["get","type"], "A", "#..", "B", "#..", ... , "#ccc"]
    const expr = ["match", ["get", TYPE_FIELD]];
    types.forEach(t => { expr.push(t, colorForType(t)); });
    expr.push("#cccccc"); // fallback
    return expr;
  }

  function setSelectedTypes(selected){
    const list = Array.from(selected);
    const filter = ["in", ["get", TYPE_FIELD], ["literal", list]];
    map.setFilter("wetlands-fill", filter);
    map.setFilter("wetlands-outline", filter);
  }

  function renderUI(types, selected){
    const container = document.getElementById("typeList");
    container.innerHTML = "";
    types.sort((a,b)=>a.localeCompare(b));
    types.forEach(t=>{
      const row = document.createElement("div"); row.className="row";
      const sw = document.createElement("span"); sw.className="swatch"; sw.style.background=colorForType(t);
      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = selected.has(t);
      cb.addEventListener("change", ()=>{
        if(cb.checked) selected.add(t); else selected.delete(t);
        setSelectedTypes(selected);
      });
      const label = document.createElement("label"); label.textContent = t || "(blank)";
      row.appendChild(sw); row.appendChild(cb); row.appendChild(label);
      container.appendChild(row);
    });

    document.getElementById("selectAll").onclick = ()=>{ selected = new Set(types); setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=true); };
    document.getElementById("clearAll").onclick  = ()=>{ selected = new Set();       setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=false); };

    // set color expression now that we know the types
    map.setPaintProperty("wetlands-fill", "fill-color", buildColorExpression(types));
  }

  // Discover types by querying visible source features once tiles load.
  map.on("idle", ()=>{
    if (!map.getLayer("wetlands-fill")) return;

    // If we've already built UI, skip
    if (map.__typesReady) return;

    const feats = map.querySourceFeatures(SOURCE_ID, {sourceLayer: SOURCE_LAYER});
    const types = new Set();
    for (const f of feats){
      const v = f.properties?.[TYPE_FIELD];
      if (typeof v === "string" && v.length) types.add(v);
    }

    // If nothing visible yet (e.g., not all tiles loaded), try again later.
    if (types.size === 0) return;

    map.__typesReady = true;

    // Default: everything ON
    let selected = new Set(types);
    renderUI(Array.from(types), selected);
    setSelectedTypes(selected);
  });
</script>
<script>
  // === ERP + Builder from combined PMTiles ===
  // Make sure this points to your uploaded file:
  const COMBINED_PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/combined.pmtiles";

  // Layer names (from tippecanoe -L erp_permits:..., -L builder_addresses:...)
  const LAYER_ERP     = "erp_permits";
  const LAYER_BUILDER = "builder_addresses";

  map.on("load", () => {
    // 1) Add the combined vector source
    map.addSource("combined", { type: "vector", url: COMBINED_PMTILES_URL });

    // 2) Builder points (magenta dots)
    map.addLayer({
      id: "builder-points",
      type: "circle",
      source: "combined",
      "source-layer": LAYER_BUILDER,
      filter: ["==", ["geometry-type"], "Point"],
      paint: {
        "circle-radius": [
          "interpolate", ["linear"], ["zoom"],
          5, 3,
          10, 5,
          14, 8
        ],
        "circle-color": "#ff00c8",
        "circle-stroke-color": "#ffffff",
        "circle-stroke-width": 1.2,
        "circle-opacity": 0.9
      }
    });

    // 3) ERP polygons — fill color depends on whether they contain a builder address
    //     has_builder_addr === true  -> pink
    //     otherwise                  -> orange
    map.addLayer({
      id: "erp-fill",
      type: "fill",
      source: "combined",
      "source-layer": LAYER_ERP,
      filter: ["in", ["geometry-type"], ["literal", ["Polygon","MultiPolygon"]]],
      paint: {
        "fill-color": [
          "case",
          ["==", ["get","has_builder_addr"], true], "#ff4fa3",  // pink
          "#ff9f1c"                                            // orange
        ],
        "fill-opacity": 0.35
      }
    });

    map.addLayer({
      id: "erp-outline",
      type: "line",
      source: "combined",
      "source-layer": LAYER_ERP,
      filter: ["in", ["geometry-type"], ["literal", ["Polygon","MultiPolygon"]]],
      paint: { "line-color": "#8a6f00", "line-width": 0.8 }
    });

    // 4) Popups — ERP polygons:
    //    Always show: permit_status, applicant, cur_prmt_id, link, prmt_proj_nm, created_date
    //    If has_builder_addr is true, also show builder_names
    const erpPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: true });

    function fmtDate(v){
      if (!v) return "";
      const m = String(v).match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
      if (!m) return String(v);
      const [_, y, mo, d] = m;
      return `${y}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }

    function erpHTML(p) {
      if (!p) return "";
      const baseRows = [
        ["Status",    p.permit_status],
        ["Applicant", p.applicant],
        ["Permit ID", p.cur_prmt_id],
        ["Project",   p.prmt_proj_nm],
        ["Created",   fmtDate(p.created_date)],
        ["Link",      p.link && /^https?:\/\//i.test(p.link) ? `<a href="${p.link}" target="_blank" rel="noopener">Open permit</a>` : (p.link||"")]
      ];

      // include builder only if present/flagged
      const rows = [...baseRows];
      if (p.has_builder_addr && p.builder_names) {
        rows.unshift(["Builder", p.builder_names]); // put builder at top
      }

      const htmlRows = rows
        .filter(([,v]) => v !== undefined && v !== null && String(v) !== "")
        .map(([k,v]) => `<tr><td style="padding-right:6px;color:#666;vertical-align:top;">${k}</td><td>${String(v)}</td></tr>`)
        .join("");

      return `
        <div style="font:12px/1.3 system-ui,sans-serif;max-width:300px">
          <div style="font-weight:600;margin-bottom:4px;">ERP Permit</div>
          <table style="border-collapse:collapse;">${htmlRows}</table>
        </div>`;
    }

    function onErpClick(e){
      if (!e.features?.length) return;
      const f = e.features[0];
      erpPopup.setLngLat(e.lngLat).setHTML(erpHTML(f.properties)).addTo(map);
    }

    map.on("click", "erp-fill", onErpClick);
    map.on("click", "erp-outline", onErpClick);

    // 5) Popups — Builder points: show matching_grantor1namefull (+ address if present)
    const bldPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: true });

    // Replace your builderHTML function with this:
    function builderHTML(p) {
      const rows = [];
      if (p?.builder)               rows.push(["builder", p.builder]);
      if (p?.address)               rows.push(["address", p.address]);
      if (p?.subdivision)           rows.push(["subdivision", p.subdivision]);
      if (p?.counta_of_attom_id!=null && p.counta_of_attom_id!=="")
                                    rows.push(["counta of attom_id", p.counta_of_attom_id]);
    
      const htmlRows = rows.map(([k,v]) =>
        `<tr><td style="padding-right:6px;color:#666;vertical-align:top;">${k}</td><td>${String(v)}</td></tr>`
      ).join("");
    
      return `
        <div style="font:12px/1.3 system-ui,sans-serif;max-width:300px">
          <div style="font-weight:600;margin-bottom:4px;">Builder Address</div>
          <table style="border-collapse:collapse;">${htmlRows}</table>
        </div>`;
    }

    map.on("click", "builder-points", (e) => {
      if (!e.features?.length) return;
      const f = e.features[0];
      bldPopup.setLngLat(e.lngLat).setHTML(builderHTML(f.properties)).addTo(map);
    });

    // Cursor affordance
    ["builder-points","erp-fill","erp-outline"].forEach(id => {
      map.on("mouseenter", id, () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", id, () => map.getCanvas().style.cursor = "");
    });
  });
</script>
</body>
</html>
