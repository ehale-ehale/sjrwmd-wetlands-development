<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Florida Wetlands — Types & Toggles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
  <style>
    html, body, #map {height:100%; margin:0}
    .panel {
      position:absolute; top:10px; left:10px; z-index:2;
      background:#fff; border-radius:10px; padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.15);
      max-height:70%; overflow:auto; font-family:system-ui, sans-serif; font-size:14px;
    }
    .row {display:flex; align-items:center; gap:8px; margin:4px 0;}
    .swatch {width:14px; height:14px; border-radius:3px; border:1px solid #888;}
    .panel h3 {margin:0 0 8px 0; font-size:15px;}
    .btns {display:flex; gap:8px; margin-bottom:6px}
    button {cursor:pointer; padding:4px 8px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7}
  </style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <h3>Wetland Types</h3>
  <div class="btns">
    <button id="selectAll">Select all</button>
    <button id="clearAll">Clear all</button>
  </div>
  <div id="typeList">Loading…</div>
</div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script>
  // ---- CONFIG ----
  const PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/wetlands.pmtiles";
  const SOURCE_ID = "wetlands";
  const SOURCE_LAYER = "wetlands";   // tippecanoe -l name (default we used)
  const TYPE_FIELD = "type";

  // ---- Map init ----
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      "version": 8,
      "sources": {
        [SOURCE_ID]: { "type": "vector", "url": PMTILES_URL }
      },
      "layers": [
        {
          "id": "wetlands-fill",
          "type": "fill",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": {
            "fill-color": "#66bb6a",     // temporary; we’ll set data-driven color after discovery
            "fill-opacity": 0.35
          },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]] // start empty; we'll populate
        },
        {
          "id": "wetlands-outline",
          "type": "line",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": { "line-color": "#22663f", "line-width": 0.6 },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]]
        }
      ]
    },
    center: [-81.5, 28.5],
    zoom: 6
  });

  // ---- Helpers ----
  // Stable color from string via simple hash → HSL
  function colorForType(s){
    let h=0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i))>>>0;
    const hue = h % 360;
    return `hsl(${hue},60%,55%)`;
  }

  function buildColorExpression(types){
    // ["match", ["get","type"], "A", "#..", "B", "#..", ... , "#ccc"]
    const expr = ["match", ["get", TYPE_FIELD]];
    types.forEach(t => { expr.push(t, colorForType(t)); });
    expr.push("#cccccc"); // fallback
    return expr;
  }

  function setSelectedTypes(selected){
    const list = Array.from(selected);
    const filter = ["in", ["get", TYPE_FIELD], ["literal", list]];
    map.setFilter("wetlands-fill", filter);
    map.setFilter("wetlands-outline", filter);
  }

  function renderUI(types, selected){
    const container = document.getElementById("typeList");
    container.innerHTML = "";
    types.sort((a,b)=>a.localeCompare(b));
    types.forEach(t=>{
      const row = document.createElement("div"); row.className="row";
      const sw = document.createElement("span"); sw.className="swatch"; sw.style.background=colorForType(t);
      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = selected.has(t);
      cb.addEventListener("change", ()=>{
        if(cb.checked) selected.add(t); else selected.delete(t);
        setSelectedTypes(selected);
      });
      const label = document.createElement("label"); label.textContent = t || "(blank)";
      row.appendChild(sw); row.appendChild(cb); row.appendChild(label);
      container.appendChild(row);
    });

    document.getElementById("selectAll").onclick = ()=>{ selected = new Set(types); setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=true); };
    document.getElementById("clearAll").onclick  = ()=>{ selected = new Set();       setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=false); };

    // set color expression now that we know the types
    map.setPaintProperty("wetlands-fill", "fill-color", buildColorExpression(types));
  }

  // Discover types by querying visible source features once tiles load.
  map.on("idle", ()=>{
    if (!map.getLayer("wetlands-fill")) return;

    // If we've already built UI, skip
    if (map.__typesReady) return;

    const feats = map.querySourceFeatures(SOURCE_ID, {sourceLayer: SOURCE_LAYER});
    const types = new Set();
    for (const f of feats){
      const v = f.properties?.[TYPE_FIELD];
      if (typeof v === "string" && v.length) types.add(v);
    }

    // If nothing visible yet (e.g., not all tiles loaded), try again later.
    if (types.size === 0) return;

    map.__typesReady = true;

    // Default: everything ON
    let selected = new Set(types);
    renderUI(Array.from(types), selected);
    setSelectedTypes(selected);
  });
</script>
<script>
  // ADD THIS: the ERP source (second .pmtiles)
  const ERP_SOURCE_ID = "erp";
  const ERP_PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/erp.pmtiles";
  const ERP_SOURCE_LAYER = "erp"; // we set this with -l erp in tippecanoe

  // Wait for map load before adding ERP layers
  map.on("load", () => {
    // Register the ERP source
    map.addSource(ERP_SOURCE_ID, {
      type: "vector",
      url: ERP_PMTILES_URL
    });

    // If your ERP contains points:
    map.addLayer({
      id: "erp-points",
      type: "circle",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: {
        "circle-radius": [
          "interpolate", ["linear"], ["zoom"],
          5, 2,
          10, 4,
          14, 6
        ],
        "circle-opacity": 0.9,
        "circle-stroke-color": "#1c3d5a",
        "circle-stroke-width": 1,
        "circle-color": "#61a5ff"
      },
      filter: ["==", ["geometry-type"], "Point"]
    });

    // If your ERP also has polygons (optional):
    map.addLayer({
      id: "erp-fill",
      type: "fill",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: { "fill-color": "#ffd166", "fill-opacity": 0.35 },
      filter: ["in", ["geometry-type"], ["literal", ["Polygon", "MultiPolygon"]]]
    });
    map.addLayer({
      id: "erp-outline",
      type: "line",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: { "line-color": "#b8860b", "line-width": 0.8 },
      filter: ["in", ["geometry-type"], ["literal", ["Polygon", "MultiPolygon"]]]
    });

    // --- Popups on click (points + polygons) ---
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: true });

  // Map from label → property key in your tiles
  const ERP_FIELDS = [
    ["Status",        "permit_status"],
    ["Applicant",     "applicant"],
    ["Permit ID",     "cur_prmt_id"],
    ["Project",       "prmt_proj_nm"],
    ["Created",       "created_date"],
    ["Link",          "link"],          // special handling below
  ];

  function fmtDateMaybe(v) {
    // Pass strings through; lightly format YYYY-MM-DD if present
    if (!v) return v;
    const m = String(v).match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
    if (!m) return v;
    const [_, y, mo, d] = m;
    return `${y}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
  }

  function popupHTML(props) {
    const rows = [];
    for (const [label, key] of ERP_FIELDS) {
      let val = props?.[key];
      if (val == null || val === "") continue;

      if (key === "created_date") val = fmtDateMaybe(val);

      if (key === "link") {
        const href = String(val);
        // Only render as a link if it looks like a URL
        if (/^https?:\/\//i.test(href)) {
          val = `<a href="${href}" target="_blank" rel="noopener noreferrer">Open permit</a>`;
        }
      }

      rows.push(
        `<tr>
           <td style="padding-right:6px;color:#666;vertical-align:top;">${label}</td>
           <td style="vertical-align:top;">${String(val)}</td>
         </tr>`
      );
    }

    // Fallback: if none of the expected keys exist, dump all properties so you can see what’s inside
    if (rows.length === 0 && props) {
      for (const [k,v] of Object.entries(props)) {
        rows.push(
          `<tr>
             <td style="padding-right:6px;color:#666;vertical-align:top;">${k}</td>
             <td style="vertical-align:top;">${String(v)}</td>
           </tr>`
        );
      }
    }

    return `
      <div style="font: 12px/1.3 system-ui, sans-serif; max-width: 280px">
        <div style="font-weight:600;margin-bottom:4px;">ERP Permit</div>
        <table style="border-collapse:collapse;">${rows.join("")}</table>
      </div>`;
  }

  function clickHandler(e) {
    if (!e.features?.length) return;
    const f = e.features[0];
    popup.setLngLat(e.lngLat).setHTML(popupHTML(f.properties || {})).addTo(map);
  }

  // Attach to your ERP layers (keep whatever layers you added)
  map.on("click", "erp-points", clickHandler);
  map.on("click", "erp-fill",   clickHandler);
  map.on("click", "erp-outline",clickHandler);

  // Optional: quick one-time console peek to verify property names on first click
  let __peeked = false;
  function debugPeek(e){
    if(!__peeked && e.features?.[0]) {
      console.log("ERP properties:", e.features[0].properties);
      __peeked = true;
    }
  }
  map.on("click", "erp-points", debugPeek);
  map.on("click", "erp-fill",   debugPeek);
  map.on("click", "erp-outline",debugPeek);
  });
</script>
<script>
  // --- Subdivisions vector tiles (third source) ---
  const SUBDIV_SOURCE_ID    = "subdivisions";
  const SUBDIV_PMTILES_URL  = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/volusia_subdivisions.pmtiles";
  const SUBDIV_SOURCE_LAYER = "subdivisions"; // from: tippecanoe -l subdivisions

  map.on("load", () => {
    // 1) Source
    map.addSource(SUBDIV_SOURCE_ID, {
      type: "vector",
      url: SUBDIV_PMTILES_URL
    });

    // 2) Circle layer for points
    map.addLayer({
      id: "subdiv-points",
      type: "circle",
      source: SUBDIV_SOURCE_ID,
      "source-layer": SUBDIV_SOURCE_LAYER,
      filter: ["==", ["geometry-type"], "Point"],
      paint: {
        // MUCH larger symbols
        "circle-radius": [
          "interpolate", ["linear"], ["zoom"],
          5, 4,
          10, 6,
          14, 10
        ],
        // Bright magenta so it pops against greens/yellows
        "circle-color": "#ff00ff",
        "circle-opacity": 0.9,
        "circle-stroke-color": "#ffffff",
        "circle-stroke-width": 1.2
      }
    });


    // 3) Popup
    const subdivPopup = new maplibregl.Popup({ closeButton: false, closeOnClick: true });

    // Helper: pick first non-empty value from possible keys
    function pick(props, keys) {
      for (const k of keys) {
        const v = props?.[k];
        if (v !== undefined && v !== null && String(v).trim() !== "") return v;
      }
      return "";
    }

    function subdivHTML(props) {
      const legalSubdivision = pick(props, ["legal_subdivision","legalsubdivision"]);
      const attomCount       = pick(props, ["attom_id_count","counta of attom_id"]);
      const address          = pick(props, ["address","example_address"]);
      const matchingGrantor  = pick(props, ["grantor1_full_name","matching_grantor1namefull"]);

      const rows = [
        ["Legal Subdivision", legalSubdivision],
        ["counta of attom_id", attomCount],
        ["Address", address],
        ["Matching Grantor", matchingGrantor],
      ].filter(([,v]) => v !== "");

      // Fallback: if nothing matched, show all properties to debug keys
      const tableRows = rows.length
        ? rows.map(([k,v]) => `<tr><td style="padding-right:6px;color:#666;vertical-align:top;">${k}</td><td>${String(v)}</td></tr>`).join("")
        : Object.entries(props || {}).map(([k,v]) => `<tr><td style="padding-right:6px;color:#666;vertical-align:top;">${k}</td><td>${String(v)}</td></tr>`).join("");

      return `
        <div style="font:12px/1.3 system-ui,sans-serif;max-width:280px">
          <div style="font-weight:600;margin-bottom:4px;">Subdivision</div>
          <table style="border-collapse:collapse;">${tableRows}</table>
        </div>`;
    }

    function onSubdivClick(e) {
      if (!e.features?.length) return;
      const f = e.features[0];
      subdivPopup.setLngLat(e.lngLat).setHTML(subdivHTML(f.properties)).addTo(map);
    }

    map.on("click", "subdiv-points", onSubdivClick);
    map.on("mouseenter", "subdiv-points", () => map.getCanvas().style.cursor = "pointer");
    map.on("mouseleave", "subdiv-points", () => map.getCanvas().style.cursor = "");
  });
</script>
</body>
</html>
