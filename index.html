<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Florida Wetlands — Types & Toggles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
  <style>
    html, body, #map {height:100%; margin:0}
    .panel {
      position:absolute; top:10px; left:10px; z-index:2;
      background:#fff; border-radius:10px; padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.15);
      max-height:70%; overflow:auto; font-family:system-ui, sans-serif; font-size:14px;
    }
    .row {display:flex; align-items:center; gap:8px; margin:4px 0;}
    .swatch {width:14px; height:14px; border-radius:3px; border:1px solid #888;}
    .panel h3 {margin:0 0 8px 0; font-size:15px;}
    .btns {display:flex; gap:8px; margin-bottom:6px}
    button {cursor:pointer; padding:4px 8px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7}
  </style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <h3>Wetland Types</h3>
  <div class="btns">
    <button id="selectAll">Select all</button>
    <button id="clearAll">Clear all</button>
  </div>
  <div id="typeList">Loading…</div>
</div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/index.js"></script>
<script>
  // ---- CONFIG ----
  const PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/wetlands.pmtiles";
  const SOURCE_ID = "wetlands";
  const SOURCE_LAYER = "wetlands";   // tippecanoe -l name (default we used)
  const TYPE_FIELD = "type";

  // ---- Map init ----
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      "version": 8,
      "sources": {
        [SOURCE_ID]: { "type": "vector", "url": PMTILES_URL }
      },
      "layers": [
        {
          "id": "wetlands-fill",
          "type": "fill",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": {
            "fill-color": "#66bb6a",     // temporary; we’ll set data-driven color after discovery
            "fill-opacity": 0.35
          },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]] // start empty; we'll populate
        },
        {
          "id": "wetlands-outline",
          "type": "line",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": { "line-color": "#22663f", "line-width": 0.6 },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]]
        }
      ]
    },
    center: [-81.5, 28.5],
    zoom: 6
  });

  // ---- Helpers ----
  // Stable color from string via simple hash → HSL
  function colorForType(s){
    let h=0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i))>>>0;
    const hue = h % 360;
    return `hsl(${hue},60%,55%)`;
  }

  function buildColorExpression(types){
    // ["match", ["get","type"], "A", "#..", "B", "#..", ... , "#ccc"]
    const expr = ["match", ["get", TYPE_FIELD]];
    types.forEach(t => { expr.push(t, colorForType(t)); });
    expr.push("#cccccc"); // fallback
    return expr;
  }

  function setSelectedTypes(selected){
    const list = Array.from(selected);
    const filter = ["in", ["get", TYPE_FIELD], ["literal", list]];
    map.setFilter("wetlands-fill", filter);
    map.setFilter("wetlands-outline", filter);
  }

  function renderUI(types, selected){
    const container = document.getElementById("typeList");
    container.innerHTML = "";
    types.sort((a,b)=>a.localeCompare(b));
    types.forEach(t=>{
      const row = document.createElement("div"); row.className="row";
      const sw = document.createElement("span"); sw.className="swatch"; sw.style.background=colorForType(t);
      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = selected.has(t);
      cb.addEventListener("change", ()=>{
        if(cb.checked) selected.add(t); else selected.delete(t);
        setSelectedTypes(selected);
      });
      const label = document.createElement("label"); label.textContent = t || "(blank)";
      row.appendChild(sw); row.appendChild(cb); row.appendChild(label);
      container.appendChild(row);
    });

    document.getElementById("selectAll").onclick = ()=>{ selected = new Set(types); setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=true); };
    document.getElementById("clearAll").onclick  = ()=>{ selected = new Set();       setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=false); };

    // set color expression now that we know the types
    map.setPaintProperty("wetlands-fill", "fill-color", buildColorExpression(types));
  }

  // Discover types by querying visible source features once tiles load.
  map.on("idle", ()=>{
    if (!map.getLayer("wetlands-fill")) return;

    // If we've already built UI, skip
    if (map.__typesReady) return;

    const feats = map.querySourceFeatures(SOURCE_ID, {sourceLayer: SOURCE_LAYER});
    const types = new Set();
    for (const f of feats){
      const v = f.properties?.[TYPE_FIELD];
      if (typeof v === "string" && v.length) types.add(v);
    }

    // If nothing visible yet (e.g., not all tiles loaded), try again later.
    if (types.size === 0) return;

    map.__typesReady = true;

    // Default: everything ON
    let selected = new Set(types);
    renderUI(Array.from(types), selected);
    setSelectedTypes(selected);
  });
</script>
</body>
</html>
