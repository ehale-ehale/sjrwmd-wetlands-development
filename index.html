<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Florida Wetlands — Types & Toggles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
  <style>
    html, body, #map {height:100%; margin:0}
    .panel {
      position:absolute; top:10px; left:10px; z-index:2;
      background:#fff; border-radius:10px; padding:10px 12px; box-shadow:0 2px 10px rgba(0,0,0,.15);
      max-height:70%; overflow:auto; font-family:system-ui, sans-serif; font-size:14px;
    }
    .row {display:flex; align-items:center; gap:8px; margin:4px 0;}
    .swatch {width:14px; height:14px; border-radius:3px; border:1px solid #888;}
    .panel h3 {margin:0 0 8px 0; font-size:15px;}
    .btns {display:flex; gap:8px; margin-bottom:6px}
    button {cursor:pointer; padding:4px 8px; border-radius:6px; border:1px solid #bbb; background:#f7f7f7}
  </style>
</head>
<body>
<div id="map"></div>
<div class="panel">
  <h3>Wetland Types</h3>
  <div class="btns">
    <button id="selectAll">Select all</button>
    <button id="clearAll">Clear all</button>
  </div>
  <div id="typeList">Loading…</div>
</div>

<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
<script>
  // ---- CONFIG ----
  const PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/wetlands.pmtiles";
  const SOURCE_ID = "wetlands";
  const SOURCE_LAYER = "wetlands";   // tippecanoe -l name (default we used)
  const TYPE_FIELD = "type";

  // ---- Map init ----
  let protocol = new pmtiles.Protocol();
  maplibregl.addProtocol("pmtiles", protocol.tile);

  const map = new maplibregl.Map({
    container: 'map',
    style: {
      "version": 8,
      "sources": {
        [SOURCE_ID]: { "type": "vector", "url": PMTILES_URL }
      },
      "layers": [
        {
          "id": "wetlands-fill",
          "type": "fill",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": {
            "fill-color": "#66bb6a",     // temporary; we’ll set data-driven color after discovery
            "fill-opacity": 0.35
          },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]] // start empty; we'll populate
        },
        {
          "id": "wetlands-outline",
          "type": "line",
          "source": SOURCE_ID,
          "source-layer": SOURCE_LAYER,
          "paint": { "line-color": "#22663f", "line-width": 0.6 },
          "filter": ["in", ["get", TYPE_FIELD], ["literal", []]]
        }
      ]
    },
    center: [-81.5, 28.5],
    zoom: 6
  });

  // ---- Helpers ----
  // Stable color from string via simple hash → HSL
  function colorForType(s){
    let h=0;
    for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i))>>>0;
    const hue = h % 360;
    return `hsl(${hue},60%,55%)`;
  }

  function buildColorExpression(types){
    // ["match", ["get","type"], "A", "#..", "B", "#..", ... , "#ccc"]
    const expr = ["match", ["get", TYPE_FIELD]];
    types.forEach(t => { expr.push(t, colorForType(t)); });
    expr.push("#cccccc"); // fallback
    return expr;
  }

  function setSelectedTypes(selected){
    const list = Array.from(selected);
    const filter = ["in", ["get", TYPE_FIELD], ["literal", list]];
    map.setFilter("wetlands-fill", filter);
    map.setFilter("wetlands-outline", filter);
  }

  function renderUI(types, selected){
    const container = document.getElementById("typeList");
    container.innerHTML = "";
    types.sort((a,b)=>a.localeCompare(b));
    types.forEach(t=>{
      const row = document.createElement("div"); row.className="row";
      const sw = document.createElement("span"); sw.className="swatch"; sw.style.background=colorForType(t);
      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked = selected.has(t);
      cb.addEventListener("change", ()=>{
        if(cb.checked) selected.add(t); else selected.delete(t);
        setSelectedTypes(selected);
      });
      const label = document.createElement("label"); label.textContent = t || "(blank)";
      row.appendChild(sw); row.appendChild(cb); row.appendChild(label);
      container.appendChild(row);
    });

    document.getElementById("selectAll").onclick = ()=>{ selected = new Set(types); setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=true); };
    document.getElementById("clearAll").onclick  = ()=>{ selected = new Set();       setSelectedTypes(selected); container.querySelectorAll("input[type=checkbox]").forEach(el=>el.checked=false); };

    // set color expression now that we know the types
    map.setPaintProperty("wetlands-fill", "fill-color", buildColorExpression(types));
  }

  // Discover types by querying visible source features once tiles load.
  map.on("idle", ()=>{
    if (!map.getLayer("wetlands-fill")) return;

    // If we've already built UI, skip
    if (map.__typesReady) return;

    const feats = map.querySourceFeatures(SOURCE_ID, {sourceLayer: SOURCE_LAYER});
    const types = new Set();
    for (const f of feats){
      const v = f.properties?.[TYPE_FIELD];
      if (typeof v === "string" && v.length) types.add(v);
    }

    // If nothing visible yet (e.g., not all tiles loaded), try again later.
    if (types.size === 0) return;

    map.__typesReady = true;

    // Default: everything ON
    let selected = new Set(types);
    renderUI(Array.from(types), selected);
    setSelectedTypes(selected);
  });
</script>
<script>
  // ADD THIS: the ERP source (second .pmtiles)
  const ERP_SOURCE_ID = "erp";
  const ERP_PMTILES_URL = "pmtiles://https://ehale-ehale.github.io/sjrwmd-wetlands-development/erp.pmtiles";
  const ERP_SOURCE_LAYER = "erp"; // we set this with -l erp in tippecanoe

  // Wait for map load before adding ERP layers
  map.on("load", () => {
    // Register the ERP source
    map.addSource(ERP_SOURCE_ID, {
      type: "vector",
      url: ERP_PMTILES_URL
    });

    // If your ERP contains points:
    map.addLayer({
      id: "erp-points",
      type: "circle",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: {
        "circle-radius": [
          "interpolate", ["linear"], ["zoom"],
          5, 2,
          10, 4,
          14, 6
        ],
        "circle-opacity": 0.9,
        "circle-stroke-color": "#1c3d5a",
        "circle-stroke-width": 1,
        "circle-color": "#61a5ff"
      },
      filter: ["==", ["geometry-type"], "Point"]
    });

    // If your ERP also has polygons (optional):
    map.addLayer({
      id: "erp-fill",
      type: "fill",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: { "fill-color": "#ffd166", "fill-opacity": 0.35 },
      filter: ["in", ["geometry-type"], ["literal", ["Polygon", "MultiPolygon"]]]
    });
    map.addLayer({
      id: "erp-outline",
      type: "line",
      source: ERP_SOURCE_ID,
      "source-layer": ERP_SOURCE_LAYER,
      paint: { "line-color": "#b8860b", "line-width": 0.8 },
      filter: ["in", ["geometry-type"], ["literal", ["Polygon", "MultiPolygon"]]]
    });

    // --- Popups on click (points + polygons) ---
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: true });

    function popupHTML(props) {
      // Adjust to the field names you kept in step 1
      const p = props || {};
      const rows = [
        ["Permit #", p.PERMIT_NUM],
        ["Project", p.PROJECT_NAME],
        ["Applicant", p.APPLICANT],
        ["Status", p.STATUS],
        ["County", p.COUNTY],
        ["Received", p.RECEIVED_DATE],
        ["Activity", p.ACTIVITY]
      ].filter(([_, v]) => v != null && v !== "");
      return `
        <div style="font: 12px/1.3 system-ui, sans-serif; max-width: 260px">
          <div style="font-weight:600;margin-bottom:4px;">ERP Permit</div>
          <table style="border-collapse:collapse;">
            ${rows.map(([k,v])=>`<tr><td style="padding-right:6px;color:#666;">${k}</td><td>${String(v)}</td></tr>`).join("")}
          </table>
        </div>`;
    }

    function clickHandler(e) {
      if (!e.features || !e.features.length) return;
      const f = e.features[0];
      const coords = e.lngLat;
      popup.setLngLat(coords).setHTML(popupHTML(f.properties)).addTo(map);
    }

    map.on("click", "erp-points", clickHandler);
    map.on("click", "erp-fill", clickHandler);
    map.on("click", "erp-outline", clickHandler);

    // Optional: pointer cursor on hover
    ["erp-points", "erp-fill", "erp-outline"].forEach(id => {
      map.on("mouseenter", id, () => map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", id, () => map.getCanvas().style.cursor = "");
    });
  });
</script>
</body>
</html>
